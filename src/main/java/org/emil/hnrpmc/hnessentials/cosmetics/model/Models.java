package org.emil.hnrpmc.hnessentials.cosmetics.model;

import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.vertex.VertexConsumer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.client.renderer.RenderType;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.BlockModel;
import net.minecraft.client.renderer.texture.AbstractTexture;
import net.minecraft.client.renderer.texture.OverlayTexture;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.resources.model.*;
import net.minecraft.core.Direction;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.util.RandomSource;
import net.minecraft.world.item.ItemDisplayContext;
import org.emil.hnrpmc.hnessentials.cosmetics.CosmeticaSkinManager;
import org.emil.hnrpmc.hnessentials.cosmetics.api.Model;
import org.emil.hnrpmc.hnessentials.cosmetics.utils.Scheduler;
import org.emil.hnrpmc.hnessentials.cosmetics.utils.textures.AnimatedTexture;
import org.emil.hnrpmc.hnessentials.cosmetics.utils.textures.ModelSprite;
import org.emil.hnrpmc.hnessentials.cosmetics.api.Box;

import javax.annotation.Nullable;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;


public class Models {
    private static Map<String, BakedModel> BAKED_MODELS = new HashMap<>();
    private static Set<BakedModel> NEW_BAKED_MODELS = new HashSet<>();
    private static Map<String, BakableModel> LOADED_MODELS = new HashMap<>();
    private static final float RANDOM_NEXT_FLOAT = 0.211f; // generated by random.org. Guaranteed to be random.
    public static ModelBakery thePieShopDownTheRoad;

    /**
     * PLEASE DO NOT CALL THIS DIRECTLY (call Cosmetics#clearAllCaches(), or resetTextureBasedCaches() to clear texture related caches)
     */
    public static void resetCaches() {
        LOADED_MODELS = new HashMap<>();
        resetTextureBasedCaches();
    }

    public static void resetTextureBasedCaches() {
        BAKED_MODELS = new HashMap<>();
    }

    public static Collection<String> getCachedModels() {
        return LOADED_MODELS.keySet();
    }

    @Nullable
    public static BakedModel getBakedModel(BakableModel unbaked) {
        if (unbaked == null) return null;
        if (unbaked.id() == null || unbaked.id().isEmpty()) return null;
        if (unbaked.id().charAt(0) == '-') return null;
        if (unbaked.image() == null || unbaked.model() == null) return null;

        BakedModel cached = BAKED_MODELS.get(unbaked.id());
        if (cached != null) {
            if (NEW_BAKED_MODELS.contains(cached)) return null;
            return cached;
        }

        ResourceLocation location = unbaked.image();
        AbstractTexture tex = Minecraft.getInstance().getTextureManager().getTexture(location, null);

        if (!(tex instanceof AnimatedTexture)) {
            BAKED_MODELS.remove(unbaked.id());
            return null;
        }

        ModelSprite sprite = new ModelSprite(location, (AnimatedTexture) tex);

        ModelBaker baker = new ModelBaker() {
            @Override public UnbakedModel getModel(ResourceLocation rl) { return unbaked.model(); }
            @Override public @Nullable BakedModel bake(ResourceLocation rl, ModelState state) { return this.getModel(rl).bake(this, m -> sprite, state); }
            @Override public @Nullable UnbakedModel getTopLevelModel(ModelResourceLocation m) { return null; }
            @Override public @Nullable BakedModel bake(ResourceLocation rl, ModelState s, java.util.function.Function<Material, TextureAtlasSprite> f) { return null; }
            @Override public @Nullable BakedModel bakeUncached(UnbakedModel u, ModelState s, java.util.function.Function<Material, TextureAtlasSprite> f) { return null; }
            @Override public java.util.function.Function<Material, TextureAtlasSprite> getModelTextureGetter() { return null; }
        };

        BakedModel model = baker.bake(location, BlockModelRotation.X0_Y0);
        if (model == null) {
            BAKED_MODELS.remove(unbaked.id());
            return null;
        }

        NEW_BAKED_MODELS.add(model);
        BAKED_MODELS.put(unbaked.id(), model);

        Scheduler.scheduleTask(Scheduler.Location.TEXTURE_TICK, () -> NEW_BAKED_MODELS.remove(model));

        return null;
    }


    public static void removeBakedModel(String id) {
        BAKED_MODELS.remove(id);
    }

    public static BakableModel createBakableModel(Model model) {
        String location = model.getId();

        if (location.isEmpty()) return null;

        Box bounds = model.getBoundingBox();

        if (model.isBuiltin()) {
            return LOADED_MODELS.computeIfAbsent(location, l -> new BakableModel(location, model.getName(), null, null, 0, bounds));
        }

        return LOADED_MODELS.computeIfAbsent(location, l -> {
            try (InputStream is = new ByteArrayInputStream(model.getModel().getBytes(StandardCharsets.UTF_8))) {
                BlockModel blockModel = BlockModel.fromStream(new InputStreamReader(is, StandardCharsets.UTF_8));
                blockModel.name = l;
                return new BakableModel(location, model.getName(), blockModel, CosmeticaSkinManager.processModel(model), model.flags(), bounds);
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        });
    }

    public static void renderModel(BakedModel model, PoseStack stack, MultiBufferSource multiBufferSource, ResourceLocation texture, int packedLight) {
        renderModel(model, stack, multiBufferSource, texture, packedLight, 1.0f);
    }

    public static void renderModel(BakedModel model, PoseStack stack, MultiBufferSource multiBufferSource, ResourceLocation texture, int packedLight, float alpha) {
        stack.pushPose();
        boolean isGUI3D = model.isGui3d();
        float transformStrength = 0.25F;
        float rotation = 0.0f;
        float transform = model.getTransforms().getTransform(ItemDisplayContext.GROUND).scale.y();
        stack.translate(0.0D, rotation + transformStrength * transform, 0.0D);
        float xScale = model.getTransforms().ground.scale.x();
        float yScale = model.getTransforms().ground.scale.y();
        float zScale = model.getTransforms().ground.scale.z();

        stack.pushPose();

        final ItemDisplayContext transformType = ItemDisplayContext.FIXED;
        int overlayTyp = OverlayTexture.NO_OVERLAY;
        // ItemRenderer#render start
        stack.pushPose();

        model.getTransforms().getTransform(transformType).apply(false, stack);
        stack.translate(-0.5D, -0.5D, -0.5D);

        RenderType renderType = RenderType.entityTranslucent(texture); // hopefully this is the right one
        VertexConsumer vertexConsumer4 = multiBufferSource.getBuffer(renderType);
        renderModelLists(model, packedLight, overlayTyp, stack, vertexConsumer4, alpha);

        stack.popPose();
        // ItemRenderer#render end

        stack.popPose();
        if (!isGUI3D) {
            stack.translate(0.0F * xScale, 0.0F * yScale, 0.09375F * zScale);
        }

        stack.popPose();
    }

    // vanilla code that I don't want to rewrite:

    private static void renderModelLists(BakedModel bakedModel, int packedLight, int overlayType, PoseStack poseStack, VertexConsumer vertexConsumer) {
        renderModelLists(bakedModel, packedLight, overlayType, poseStack, vertexConsumer, 1.0f);
    }

    private static void renderModelLists(BakedModel bakedModel, int packedLight, int overlayType, PoseStack poseStack, VertexConsumer vertexConsumer, float alpha) {
        RandomSource randomSource = RandomSource.create();
        final long seed = 42L;
        Direction[] var10 = Direction.values();
        int var11 = var10.length;

        for(int var12 = 0; var12 < var11; ++var12) {
            Direction direction = var10[var12];
            randomSource.setSeed(seed);
            renderQuadList(poseStack, vertexConsumer, bakedModel.getQuads(null, direction, randomSource), packedLight, overlayType, alpha);
        }

        randomSource.setSeed(seed);
        renderQuadList(poseStack, vertexConsumer, bakedModel.getQuads(null, null, randomSource), packedLight, overlayType, alpha);
    }

    private static void renderQuadList(PoseStack poseStack, VertexConsumer vertexConsumer, List<BakedQuad> list, int i, int j) {
        renderQuadList(poseStack, vertexConsumer, list, i, j, 1.0f);
    }

    private static void renderQuadList(PoseStack poseStack, VertexConsumer vertexConsumer, List<BakedQuad> list, int i, int j, float alpha) {
        PoseStack.Pose pose = poseStack.last();
        Iterator var9 = list.iterator();

        while(var9.hasNext()) {
            BakedQuad bakedQuad = (BakedQuad)var9.next();
            int k = -1;

            float f = (float)(k >> 16 & 255) / 255.0F;
            float g = (float)(k >> 8 & 255) / 255.0F;
            float h = (float)(k & 255) / 255.0F;
            vertexConsumer.putBulkData(pose, bakedQuad, f, g, h, alpha, i, j);
        }
    }
}